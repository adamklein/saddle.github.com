
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Quick Start Guide &mdash; Saddle 1.0.0 documentation</title>
    
    <link rel="stylesheet" href="_static/saddle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Saddle 1.0.0 documentation" href="index.html" />
    <link rel="next" title="User Guide" href="guide.html" />
    <link rel="prev" title="Welcome to Saddle Docs" href="index.html" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head>
  <body>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="quick-start-guide">
<h1>Quick Start Guide<a class="headerlink" href="#quick-start-guide" title="Permalink to this headline">¶</a></h1>
<p>Let&#8217;s take a quick tour through Saddle to get a sense of the feature set. There
are four major data structures:</p>
<ul class="simple">
<li>Vec, a 1D vector object</li>
<li>Series, a 1D indexed vector object</li>
<li>Mat, a 2D matrix object</li>
<li>Frame, a 2D indexed matrix object</li>
</ul>
<p>All are designed with immutability in mind, although since they are backed by arrays
and the library tries to be conservative in copying data, you should be careful not
to let the backing arrays escape object construction.</p>
<p>Let&#8217;s look at each one in turn through examples. If you&#8217;ve got the source code and an
SBT launcher, run the following (from the directory where you&#8217;ve got Saddle checked
out):</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">$</span> <span class="n">sbt</span> <span class="n">console</span>
</pre></div>
</div>
<p>If you&#8217;ve only got the Saddle jar in your classpath, the relevant import is:</p>
<div class="code scala highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">org.saddle._</span>
</pre></div>
</div>
<p>Note: by default, toString will print up to some number of data entries. If you would like
to see more data, simply call the print() method on the relevant object with a larger number.</p>
<div class="section" id="vec">
<h2>Vec<a class="headerlink" href="#vec" title="Permalink to this headline">¶</a></h2>
<p>Let&#8217;s walk through some examples in an sbt console session.</p>
<p>First, a few ways to create Vec instances:</p>
<div class="code scala highlight-scala"><pre>scala&gt; Vec(1, 2, 3)               // pass a sequence directly
res0: org.saddle.Vec[Int] =
[3 x 1]
1
2
3

scala&gt; Vec(1 to 3 : _*)           // pass a sequence indirectly
res1: org.saddle.Vec[Int] =
[3 x 1]
1
2
3

scala&gt; Vec(Array(1,2,3))          // wrap an array into a Vec
res2: org.saddle.Vec[Int] =
[3 x 1]
1
2
3

scala&gt; Vec(Seq(1,2,3))            // not usually what you want!
res3: org.saddle.Vec[Seq[Int]] =
[1 x 1]
List(1, 2, 3)

scala&gt; Vec(Seq(1,2,3) : _*)       // yes, usually what you want!
res3: org.saddle.Vec[Int] =
[3 x 1]
1
2
3

scala&gt; Vec.empty[Double]          // create an empty Vec
res4: org.saddle.Vec[Double] = Empty Vec</pre>
</div>
<p>There are also a few special factories:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">vec</span><span class="o">.</span><span class="n">ones</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">vec</span><span class="o">.</span><span class="n">zeros</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
</pre></div>
</div>
<p>Sometimes random Vec instances are useful. There are a few ways to accomplish
this:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">vec</span><span class="o">.</span><span class="n">rand</span><span class="o">(</span><span class="mi">1000</span><span class="o">)</span>             <span class="c1">// 1000 random doubles, -1.0 to 1.0 (excluding 0)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">vec</span><span class="o">.</span><span class="n">randp</span><span class="o">(</span><span class="mi">1000</span><span class="o">)</span>            <span class="c1">// a thousand random positive doubles</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">vec</span><span class="o">.</span><span class="n">randi</span><span class="o">(</span><span class="mi">1000</span><span class="o">)</span>            <span class="c1">// a thousand random ints</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">vec</span><span class="o">.</span><span class="n">randpi</span><span class="o">(</span><span class="mi">1000</span><span class="o">)</span> <span class="o">%</span> <span class="mi">10</span>      <span class="c1">// a thousand random positive ints, from 1 to 9</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">vec</span><span class="o">.</span><span class="n">randn</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>             <span class="c1">// 100 normally distributed observations</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">vec</span><span class="o">.</span><span class="n">randn2</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">15</span><span class="o">)</span>          <span class="c1">// 100 obs normally distributed with mean 2 and stdev 15</span>
</pre></div>
</div>
<p>Let&#8217;s take a quick look at some operations you can do on Vec instances. All the
major arithmetic operations are supported between two Vec instances and between
a Vec and a scalar.</p>
<div class="code bash highlight-scala"><pre>scala&gt; Vec(1,2,3) + Vec(4,5,6)
res0: org.saddle.Vec[Int] =
[3 x 1]
5
7
9

scala&gt; Vec(1,2,3) * Vec(4,5,6)
res1: org.saddle.Vec[Int] =
[3 x 1]
 4
10
18

scala&gt; Vec(1,2,3) dot Vec(4,5,6)
res2: Int = 32

scala&gt; Vec(1,2,3) outer Vec(4,5,6)
res3: org.saddle.Mat[Int] =
[3 x 3]
 4  5  6
 8 10 12
12 15 18

scala&gt; Vec(1,2,3) ** Vec(4,5,6)
res4: org.saddle.Vec[Int] =
[3 x 1]
  1
 32
729

scala&gt; Vec(1,2,3) &lt;&lt; 2
res5: org.saddle.Vec[Int] =
[3 x 1]
 4
 8
12

scala&gt; Vec(1,2,3) &amp; 0x1
res6: org.saddle.Vec[Int] =
[3 x 1]
1
0
1

// NB: 2 must be on the RHS, as `+` is a method on Vec
scala&gt; Vec(1,2,3) + 2
res7: org.saddle.Vec[Int] =
[3 x 1]
 3
 4
 5</pre>
</div>
<p>You can also slice out data from a Vec in various ways:</p>
<div class="code bash highlight-scala"><pre>scala&gt; val v = vec.rand(10)

scala&gt; v.at(2)                        // wrapped in Scalar, in case of NA
res0: org.saddle.scalar.Scalar[Double] = -0.19816001024987906

scala&gt; v.raw(2)                       // raw access to primitive type
res1: Double = -0.19816001024987906

scala&gt; v(2,4,8)
res2: org.saddle.Vec[Double] =
[3 x 1]
-0.1982
 0.8767
 0.6785

scala&gt; v(2 -&gt; 4)
res3: org.saddle.Vec[Double] =
[3 x 1]
-0.1982
-0.0759
 0.8767

scala&gt; v(* -&gt; 3)
res4: org.saddle.Vec[Double] =
[4 x 1]
 0.2856
 0.0315
-0.1982
-0.0759

scala&gt; v(8 -&gt; * )
res5: org.saddle.Vec[Double] =
[2 x 1]
0.6785
0.2523

scala&gt; v.slice(0,3)
res6: org.saddle.Vec[Double] =
[3 x 1]
 0.2856
 0.0315
-0.1982

scala&gt; v.slice(0,8,2)
res7: org.saddle.Vec[Double] =
[4 x 1]
 0.2856
-0.1982
 0.8767
 0.9350</pre>
</div>
<p>There are statistical functions available:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">v</span> <span class="k">=</span> <span class="nc">Vec</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">sum</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">6</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">prod</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">6</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">mean</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">2.0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">median</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">2.0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">max</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">stdev</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">variance</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">skew</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">0.0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">kurt</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="nc">NaN</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">geomean</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">1.8171205928321394</span>

<span class="c1">// etc ...</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">count</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">countif</span><span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">logsum</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">argmin</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">percentile</span><span class="o">(</span><span class="mf">0.3</span><span class="o">,</span> <span class="n">method</span><span class="k">=</span><span class="nc">PctMethod</span><span class="o">.</span><span class="nc">NIST</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">demeaned</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">rank</span><span class="o">(</span><span class="n">tie</span><span class="k">=</span><span class="nc">RankTie</span><span class="o">.</span><span class="nc">Avg</span><span class="o">,</span> <span class="n">ascending</span><span class="k">=</span><span class="kc">true</span><span class="o">)</span>
</pre></div>
</div>
<p>As well as a few rolling statistical functions:</p>
<div class="code bash highlight-scala"><pre>scala&gt; val v = vec.rand(10)

scala&gt; v.rollingSum(5)            // with window size = 5
res0: org.saddle.Vec[Double] =
[6 x 1]
-3.5240
-2.2592
-0.5084
-0.0990
 0.4410
 0.3806

// etc...
scala&gt; v.rollingMean(5)
scala&gt; v.rollingMedian(5)
scala&gt; v.rollingCount(5)</pre>
</div>
<p>In fact, you can do any calculation you&#8217;d like over the rolling window:</p>
<div class="code bash highlight-scala"><pre>scala&gt; v.rolling(5, _.stdev)      // window size = 5, take stdev of vector input
res0: org.saddle.Vec[Double] =
[6 x 1]
0.5456
0.3810
0.3685
0.2678
0.6302
0.4969</pre>
</div>
<p>Let&#8217;s take a quick look at some more advanced functionality:</p>
<div class="code bash highlight-scala"><pre>scala&gt; val v = vec.rand(10)
v: org.saddle.Vec[Double] =
[10 x 1]
-0.0137
 0.8427
-0.0089
 0.2083
 0.9968
-0.3560
-0.5520
-0.2475
-0.5036
-0.3474

scala&gt; v filter(_ &gt; 0.5)
res0: org.saddle.Vec[Double] =
[2 x 1]
0.8427
0.9968

scala&gt; v where v &gt; 0.5
res1: org.saddle.Vec[Double] =
[2 x 1]
0.8427
0.9968

scala&gt; v.take(v.find(_ &gt; 0.5))
res2: org.saddle.Vec[Double] =
[2 x 1]
0.8427
0.9968

scala&gt; v.filterFoldLeft(_ &gt; 0.5)(0d) { case (acc, d) =&gt; acc + d }
res3: Double = 1.8394622034464525

scala&gt; v shift 1
res4: org.saddle.Vec[Double] =
[10 x 1]
     NA
-0.0137
 0.8427
-0.0089
 0.2083
 0.9968
-0.3560
-0.5520
-0.2475
-0.5036</pre>
</div>
<p>Try out the following for yourself:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">reversed</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="mi">0</span><span class="n">d</span><span class="o">)</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">acc</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">d</span> <span class="o">}</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">scanLeft</span><span class="o">(</span><span class="mi">0</span><span class="n">d</span><span class="o">)</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">acc</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">d</span> <span class="o">}</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span> <span class="n">without</span> <span class="n">v</span><span class="o">.</span><span class="n">find</span><span class="o">(</span><span class="k">_</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span> <span class="n">findOne</span><span class="o">(</span><span class="k">_</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">head</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">tail</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">(</span><span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">).</span><span class="n">mask</span><span class="o">(</span><span class="nc">Vec</span><span class="o">(</span><span class="kc">true</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">))</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span> <span class="n">concat</span> <span class="n">v</span>
</pre></div>
</div>
<p>Note that NA (missing values) are handled within most calculations. Saddle
tries to prevent accidentally using raw NA values; only two primitive types,
Float and Double, have NA values that are safe to use in raw form. (Their NA
representations are Float.NaN and Double.NaN, respectively.)</p>
<div class="code bash highlight-scala"><pre>scala&gt; val v = Vec(1, na.to[Int], 2)
v: org.saddle.Vec[Int] =
[3 x 1]
 1
NA
 2

scala&gt; v sum
res0: Int = 3

scala&gt; v median
res1: Double = 1.5

scala&gt; v prod
res2: Int = 2

scala&gt; v dropNA
res3: org.saddle.Vec[Int] =
[2 x 1]
1
2

scala&gt; v.at(1)                    // boxed to prevent shooting yourself in foot
res4: org.saddle.scalar.Scalar[Int] = NA

scala&gt; v.raw(1)                   // you can do this, but be careful!
res5: Int = -2147483648

scala&gt; v.fillNA(_ =&gt; 5)           // ignore argument, which is index of NA
res6: org.saddle.Vec[Int] =
[3 x 1]
1
5
2

scala&gt; val d: Double = Scalar(1.0) // you can auto-unbox a double scalar</pre>
</div>
<p>Also, a Scalar[T] can convert to Option[T] implicitly, so you may do everything
with it that you may do with an Option; e.g., call map() or flatmap().</p>
<p>Finally, if you need to treat a Vec as a sequence, you may convert it to Seq,
(specifically, an IndexedSeq). Also, you may access (a copy of) Vec as an array,
by calling Vec.contents.</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">toSeq</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">contents</span>
</pre></div>
</div>
</div>
<div class="section" id="series">
<h2>Series<a class="headerlink" href="#series" title="Permalink to this headline">¶</a></h2>
<p>A Series combines a Vec with an Index that provides an ordered key-value mapping.
We&#8217;ll talk more about the details of Index later.  First, note a Vec[T] can convert
implicitly to a Series[Int, T]. So for instance:</p>
<div class="code bash highlight-scala"><pre>scala&gt; val x: Series[Int, Double] = vec.rand(5)
x: org.saddle.Series[Int,Double] =
[5 x 1]
0 -&gt; -0.7846
1 -&gt;  0.0297
2 -&gt; -0.2634
3 -&gt; -0.0976
4 -&gt;  0.1756</pre>
</div>
<p>The key type of a must have a natural ordering (ie, an Ordering of that type within
the implicit scope). However, the Series maintains the order in which its data was
supplied unless ordered othewise.</p>
<p>Let&#8217;s look at a few constructions:</p>
<div class="code bash highlight-scala"><pre>// we already know we can convert a Vec
scala&gt; Series(Vec("a", "b", "c"))
res3: org.saddle.Series[Int,java.lang.String] =
[3 x 1]
0 -&gt; a
1 -&gt; b
2 -&gt; c

// we can pass a pair of tuples
scala&gt; Series("a" -&gt; 1, "b" -&gt; 2, "c" -&gt; 3)
res4: org.saddle.Series[java.lang.String,Int] =
[3 x 1]
a -&gt; 1
b -&gt; 2
c -&gt; 3

// any series of tuples will work, eg:
scala&gt; Series(List("a" -&gt; 1, "b" -&gt; 2, "c" -&gt; 3) : _*)

// can pass data and index separately:
scala&gt; Series(Vec(1,2,3), Index("a", "b", "c"))

// you can create an empty Series like so:
scala&gt; Series.empty[String, Int]

// supplied order is maintained:
scala&gt; Series(Vec(1,2,3), Index("c", "b", "a"))
res11: org.saddle.Series[java.lang.String,Int] =
[3 x 1]
c -&gt; 1
b -&gt; 2
a -&gt; 3

// unlike map, multiple keys are entirely fine:
scala&gt; Series(Vec(1,2,3,4), Index("c", "b", "a", "b"))
res12: org.saddle.Series[java.lang.String,Int] =
[4 x 1]
c -&gt; 1
b -&gt; 2
a -&gt; 3
b -&gt; 4</pre>
</div>
<p>With construction out of the way, let&#8217;s look at a few ways
we can get data out of a Series.</p>
<div class="code bash highlight-scala"><pre>scala&gt; val q = Series(Vec(1,3,2,4), Index("c", "b", "a", "b"))

// get the values or index
scala&gt; q.values
scala&gt; q.index

// extract value by numerical offset
scala&gt; q.at(2)
res20: org.saddle.scalar.Scalar[Int] = 3

scala&gt; q.at(2,3,1)
res0: org.saddle.Vec[Int] =
[3 x 1]
2
4
3

// or extract key
scala&gt; q.keyAt(2)
res21: org.saddle.scalar.Scalar[java.lang.String] = a

scala&gt; q.keyAt(2,3,1)
res24: org.saddle.Index[java.lang.String] =
[Index 3 x 1]
a
b
b

// sort by index ordering
scala&gt; q.sortedIx
res16: org.saddle.Series[java.lang.String,Int] =
[4 x 1]
a -&gt; 3
b -&gt; 2
b -&gt; 4
c -&gt; 1

// sort by value ordering
scala&gt; q.sorted
res17: org.saddle.Series[java.lang.String,Int] =
[4 x 1]
c -&gt; 1
b -&gt; 2
a -&gt; 3
b -&gt; 4

// extract elements matching the index
scala&gt; q("b")
res19: org.saddle.Series[java.lang.String,Int] =
[2 x 1]
b -&gt; 2
b -&gt; 4

scala&gt; q("a", "b")
res1: org.saddle.Series[java.lang.String,Int] =
[3 x 1]
a -&gt; 2
b -&gt; 3
b -&gt; 4

// notice ordering subtleties:
scala&gt; q("b", "a")
res2: org.saddle.Series[java.lang.String,Int] =
[3 x 1]
b -&gt; 3
b -&gt; 4
a -&gt; 2

// get first or last values
scala&gt; q.first
scala&gt; q.last

// or key
scala&gt; q.firstKey
scala&gt; q.lastKey

// "reindex" to a new index:
scala&gt; q.reindex(Index("a","c","d"))
res4: org.saddle.Series[java.lang.String,Int] =
[3 x 1]
a -&gt;  2
c -&gt;  1
d -&gt; NA

// or just by a sequence of keys:
scala&gt; q.reindex("a","c","d")

// notice that 'slicing' ignores unknown keys:
scala&gt; q("a", "d")
res5: org.saddle.Series[java.lang.String,Int] =
[1 x 1]
a -&gt; 2

// we cannot reindex with "b", because it isn't unique.
// (the problem is, which "b" would we choose?)
scala&gt; q.reindex("a", "b")
java.lang.IllegalArgumentException: requirement failed: Could not reindex unambiguously
...

// we can "reset" the index to integer labels
scala&gt; q.resetIndex

// or to a new index altogether
scala&gt; q.setIndex(Index("w", "x", "y", "z"))

// to 'slice', we need a sorted index; slice is inclusive by default
scala&gt; val s = q.sortedIx
scala&gt; s.sliceBy("b", "c")
res7: org.saddle.Series[java.lang.String,Int] =
[3 x 1]
b -&gt; 3
b -&gt; 4
c -&gt; 1

// syntactic sugar is provided:
scala&gt; s.sliceBy("b" -&gt; "c")
scala&gt; s.sliceBy(* -&gt; "b")

// where slice is by offset, exclusive by default, and the
// index doesn't have to be sorted:
scala&gt; q.slice(0,2)
res8: org.saddle.Series[java.lang.String,Int] =
[2 x 1]
c -&gt; 1
b -&gt; 3

// there are head/tail methods:
scala&gt; q.head(2)
scala&gt; q.tail(2)</pre>
</div>
<p>Aside from extracting values, there are many fun ways to compute with Series.
Try the following:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">q</span> <span class="k">=</span> <span class="nc">Series</span><span class="o">(</span><span class="nc">Vec</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">),</span> <span class="nc">Index</span><span class="o">(</span><span class="s">&quot;c&quot;</span><span class="o">,</span> <span class="s">&quot;b&quot;</span><span class="o">,</span> <span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;b&quot;</span><span class="o">))</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">mapValues</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">mapIndex</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="s">&quot;x&quot;</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">shift</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">filterIx</span><span class="o">(</span><span class="k">_</span> <span class="o">!=</span> <span class="s">&quot;b&quot;</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">find</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">findKey</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">findOneKey</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">minKey</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">scanLeft</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">acc</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">v</span> <span class="o">}</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">reversed</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">m</span> <span class="k">=</span> <span class="n">q</span><span class="o">.</span><span class="n">mask</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="n">values</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">hasNA</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">dropNA</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">pad</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">rolling</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="k">_</span><span class="o">.</span><span class="n">minKey</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">splitAt</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">sortedIx</span><span class="o">.</span><span class="n">splitBy</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>We can of course convert to a Vec or a Seq if we need to:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">toVec</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">toSeq</span>
</pre></div>
</div>
<p>We can also group by key in order to transform or combine the groupings, which
themselves are Series. For example:</p>
<div class="code bash highlight-scala"><pre>scala&gt; q.groupBy.combine(_.sum)
res19: org.saddle.Series[java.lang.String,Int] =
[3 x 1]
a -&gt; 2
b -&gt; 7
c -&gt; 1

scala&gt; q.groupBy.transform(s =&gt; s - s.mean)
res20: org.saddle.Series[java.lang.String,Double] =
[4 x 1]
c -&gt;  0.0000
b -&gt; -0.5000
a -&gt;  0.0000
b -&gt;  0.5000</pre>
</div>
<p>You can also group by another index, or by a transformation of the current index,
by passing an argument into groupBy. See the Saddle API for more info.</p>
<p>The expressive nature of working with Series becomes apparent when you need to
align data:</p>
<div class="code bash highlight-scala"><pre>scala&gt; val a = Series(Vec(1,4,2,3), Index("a","b","c","d"))
scala&gt; val b = Series(Vec(5,2,1,8,7), Index("b","c","d","e","f"))

scala&gt; a + b
res21: org.saddle.Series[java.lang.String,Int] =
[6 x 1]
a -&gt; NA
b -&gt;  9
c -&gt;  4
d -&gt;  4
e -&gt; NA
f -&gt; NA</pre>
</div>
<p>You see that the indexes have been aligned prior to operation being performed. Because
there is a missing observation in each label of a, e, and f, the summation is not done
and instead an NA value is inserted into the result.</p>
<p>Generally, a full-outer join is performed. So, for instance:</p>
<div class="code bash highlight-scala"><pre>scala&gt; val a = Series(Vec(1,4,2), Index("a","b","b"))
scala&gt; val b = Series(Vec(5,2,1), Index("b","b","d"))

scala&gt; a + b
res22: org.saddle.Series[java.lang.String,Int] =
[6 x 1]
a -&gt; NA
b -&gt;  9
b -&gt;  6
b -&gt;  7
b -&gt;  4
d -&gt; NA</pre>
</div>
<p>Most basic math and boolean operations are supported between two Series, as well as between
a Series and a scalar value.</p>
<p>We mentioned joins. Let&#8217;s look at a few join operations; the result is a Frame, which we will
touch on a bit later. These are similar in nature to SQL joins.</p>
<div class="code bash highlight-scala"><pre>scala&gt; val a = Series(Vec(1,4,2), Index("a","b","b"))
scala&gt; val b = Series(Vec(5,2,1), Index("b","b","d"))

scala&gt; a.join(b, how=index.LeftJoin)
res24: org.saddle.Frame[java.lang.String,Int,Int] =
[4 x 2]
      0  1
     -- --
a -&gt;  1 NA
b -&gt;  4  5
b -&gt;  4  2
b -&gt;  2  2

scala&gt; a.join(b, how=index.RightJoin)
res25: org.saddle.Frame[java.lang.String,Int,Int] =
[4 x 2]
      0  1
     -- --
b -&gt;  4  5
b -&gt;  2  5
b -&gt;  2  2
d -&gt; NA  1

scala&gt; a.join(b, how=index.InnerJoin)
res28: org.saddle.Frame[java.lang.String,Int,Int] =
[3 x 2]
      0  1
     -- --
b -&gt;  4  5
b -&gt;  4  2
b -&gt;  2  2

scala&gt; a.join(b, how=index.OuterJoin)
res29: org.saddle.Frame[java.lang.String,Int,Int] =
[6 x 2]
      0  1
     -- --
a -&gt;  1 NA
b -&gt;  4  5
b -&gt;  4  2
b -&gt;  2  5
b -&gt;  2  2
d -&gt; NA  1</pre>
</div>
<p>Finally, let&#8217;s take a look at a multiply indexed Series:</p>
<div class="code bash highlight-scala"><pre>scala&gt; val t = Series(Vec(1,2,3,4), Index((1,1),(1,2),(2,1),(2,2)))
t: org.saddle.Series[(Int, Int),Int] =
[4 x 1]
1 1 -&gt; 1
  2 -&gt; 2
2 1 -&gt; 3
  2 -&gt; 4</pre>
</div>
<p>Sometimes you want to move the innermost row label to be a column label instead.
You can achieve this as follows:</p>
<div class="code bash highlight-scala"><pre>scala&gt; val f = t.pivot
f: org.saddle.Frame[Int,Int,Int] =
[2 x 2]
      1  2
     -- --
1 -&gt;  1  2
2 -&gt;  3  4</pre>
</div>
<p>And this is how you get back the original Series:</p>
<div class="code bash highlight-scala"><pre>scala&gt; f.melt
res32: org.saddle.Series[(Int, Int),Int] =
[4 x 1]
1 1 -&gt; 1
  2 -&gt; 2
2 1 -&gt; 3
  2 -&gt; 4</pre>
</div>
<p>This generalizes to tuples of higher order.</p>
</div>
<div class="section" id="mat">
<h2>Mat<a class="headerlink" href="#mat" title="Permalink to this headline">¶</a></h2>
<p>A Mat[T] represents a Matrix of values. Internally it is stored as a single
contiguous array; sometimes, a duplicate array is created which stores the
same values, but transposed, for speed of access having to do with memory
locality.</p>
<p>This format was chosen to be compatible with DenseMatrix of <a class="reference external" href="http://code.google.com/p/efficient-java-matrix-library/">EJML</a>, a high
performance linear algebra library which provides the default matrix multiply
routine for Saddle. One or two properly placed implicit conversions can extend
Saddle to be a powerful linear algebra system.</p>
<p>Let&#8217;s start off with construction:</p>
<div class="code bash highlight-scala"><pre>scala&gt; Mat(2,2, Array(1,2,3,4))
res41: org.saddle.Mat[Int] =
[2 x 2]
1 2
3 4

// all same:
scala&gt; Mat(Array(1,3), Array(2,4))
scala&gt; Mat(Array(Array(1,3), Array(2,4)))
scala&gt; Mat(Vec(1,3), Vec(2,4))
scala&gt; Mat(Array(Vec(1,3), Vec(2,4)))

// identity matrix:
scala&gt; mat.ident(2)

// empty matrix:
scala&gt; Mat.empty[Double]

// zeros:
scala&gt; Mat[Int](2, 2)</pre>
</div>
<p>Again, sometimes we want to create instances filled with random observations. As
to Vec, we can do the following:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">mat</span><span class="o">.</span><span class="n">rand</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">)</span>       <span class="c1">// random doubles from within [-1.0, 1.0] excluding 0</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">mat</span><span class="o">.</span><span class="n">randp</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">)</span>      <span class="c1">// random positive doubles</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">mat</span><span class="o">.</span><span class="n">randn</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">)</span>      <span class="c1">// random normally distributed doubles</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">mat</span><span class="o">.</span><span class="n">randn</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">12</span><span class="o">)</span> <span class="c1">// random normally distributed with mean=3, stdev=12</span>
</pre></div>
</div>
<p>There are a few other factory methods available:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">mat</span><span class="o">.</span><span class="n">ones</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">mat</span><span class="o">.</span><span class="n">zeros</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">mat</span><span class="o">.</span><span class="n">diag</span><span class="o">(</span><span class="nc">Vec</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">))</span>
</pre></div>
</div>
<p>Let&#8217;s look at some basic operations with Mat. As with Vec, you may perform
calculations on two Mat instances, or on a Mat and a scalar value.</p>
<div class="code bash highlight-scala"><pre>// element-wise multiplication
scala&gt; Mat(2,2,Array(1,2,3,4)) * Mat(2,2,Array(4,1,2,3))
res55: org.saddle.Mat[Int] =
[2 x 2]
 4  2
 6 12

// matrix multiplication; note implicit conversion to Double
// instead of `dot`, can also use `mult`
scala&gt; Mat(2,2,Array(1,2,3,4)) dot Mat(2,2,Array(4,1,2,3))
res53: org.saddle.Mat[Double] =
[2 x 2]
 8.0000  7.0000
20.0000 15.0000


// matrix-vector multiplication
scala&gt; Mat(2,2,Array(1,2,3,4)) dot Vec(2,1)
res56: org.saddle.Mat[Double] =
[2 x 1]
 4.0000
10.0000

// as expected
scala&gt; Mat(2,2,Array(1,2,3,4)) * 2
scala&gt; Mat(2,2,Array(1,2,3,4)) + 2
scala&gt; Mat(2,2,Array(1,2,3,4)) &lt;&lt; 2
// etc...

// transpose
scala&gt; Mat(2,2,Array(1,2,3,4)).T
scala&gt; Mat(2,2,Array(1,2,3,4)).transposed

// properties of Mat
scala&gt; val m = Mat(2,2,Array(1,2,3,4))
scala&gt; m.numRows
scala&gt; m.numCols
scala&gt; m.isSquare
scala&gt; m.isEmpty</pre>
</div>
<p>There are a few ways to extract values from a Mat.</p>
<div class="code bash highlight-scala"><pre>scala&gt; m.at(0,1)
res1: org.saddle.scalar.Scalar[Int] = 2

// be careful with this one!
scala&gt; m.raw(0,1)
res2: Int = 2

scala&gt; m.takeRows(0)
res0: org.saddle.Mat[Int] =
[1 x 2]
1 2

scala&gt; m.withoutRows(0)
res0: org.saddle.Mat[Int] =
[1 x 2]
3 4

scala&gt; m.takeCols(0)
res1: org.saddle.Mat[Int] =
[2 x 1]
1
3

scala&gt; m.col(0)
scala&gt; m.row(0)
scala&gt; m.rows()
scala&gt; m.cols()</pre>
</div>
<p>Some other interesting methods on Mat:</p>
<div class="code bash highlight-scala"><pre>scala&gt; val m = Mat(2,2,Array(1,2,na.to[Int],4))
m: org.saddle.Mat[Int] =
[2 x 2]
 1  2
NA  4

scala&gt; m.rowsWithNA
res4: List[Int] = List(1)

scala&gt; m.dropRowsWithNA

scala&gt; m.reshape(1,4)
res6: org.saddle.Mat[Int] =
[1 x 4]
 1  2 NA  4

scala&gt; mat.rand(2,2).roundTo(2)
res8: org.saddle.Mat[Double] =
[2 x 2]
-0.3400  0.0000
-0.3800  0.2500</pre>
</div>
<p>Finally, if you want to print, say, 100 rows and 10 columns:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">print</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
</pre></div>
</div>
</div>
<div class="section" id="frame">
<h2>Frame<a class="headerlink" href="#frame" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebarwrapper">
      <div class="sphinxsidebar">
  <div class="logo">
    <a href="index.html">
      <img class="logo" src="_static/logo.png" width=200 alt="Logo"/>
    </a>
  </div>
  <ul>
<li><a class="reference internal" href="#">Quick Start Guide</a><ul>
<li><a class="reference internal" href="#vec">Vec</a></li>
<li><a class="reference internal" href="#series">Series</a></li>
<li><a class="reference internal" href="#mat">Mat</a></li>
<li><a class="reference internal" href="#frame">Frame</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Welcome to Saddle Docs</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="guide.html"
                        title="next chapter">User Guide</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
        &copy; Copyright 2013, The Saddle Development Team.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>