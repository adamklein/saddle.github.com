
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Quick Start Guide &mdash; Saddle 1.0.0 documentation</title>
    
    <link rel="stylesheet" href="_static/saddle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Saddle 1.0.0 documentation" href="index.html" />
    <link rel="next" title="User Guide" href="guide.html" />
    <link rel="prev" title="Welcome to Saddle Docs" href="index.html" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head>
  <body>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="quick-start-guide">
<h1>Quick Start Guide<a class="headerlink" href="#quick-start-guide" title="Permalink to this headline">¶</a></h1>
<p>Let&#8217;s take a quick tour through Saddle to get a sense of the feature set. There are four
major data structures to be aware of:</p>
<ul class="simple">
<li>Vec, a 1D vector object</li>
<li>Series, a 1D indexed vector object</li>
<li>Mat, a 2D matrix object</li>
<li>Frame, a 2D indexed matrix object</li>
</ul>
<p>Let&#8217;s look at each one in turn through examples. If you&#8217;ve got the source code and an SBT
launcher, run the following (from the directory where you&#8217;ve got Saddle checked out):</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">$</span> <span class="n">sbt</span> <span class="n">console</span>
</pre></div>
</div>
<p>If you&#8217;ve only got the Saddle jar in your classpath, the relevant import is:</p>
<div class="code scala highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">org.saddle._</span>
</pre></div>
</div>
<div class="section" id="vec">
<h2>Vec<a class="headerlink" href="#vec" title="Permalink to this headline">¶</a></h2>
<p>Let&#8217;s walk through some examples in an sbt console session.</p>
<p>First, a few ways to create Vec instances:</p>
<div class="code bash highlight-scala"><pre>scala&gt; Vec(1, 2, 3)               // pass a sequence directly
res0: org.saddle.Vec[Int] =
[3 x 1]
1
2
3

scala&gt; Vec(1 to 3 : _*)           // pass a sequence indirectly
res1: org.saddle.Vec[Int] =
[3 x 1]
1
2
3

scala&gt; Vec(Array(1,2,3))          // wrap an array
res2: org.saddle.Vec[Int] =
[3 x 1]
1
2
3

scala&gt; Vec(Seq(1,2,3))            // not usually what you want!
res3: org.saddle.Vec[Seq[Int]] =
[1 x 1]
List(1, 2, 3)

scala&gt; Vec(Seq(1,2,3) : _*)       // yes, usually what you want!
res3: org.saddle.Vec[Int] =
[3 x 1]
1
2
3

scala&gt; Vec.empty[Double]          // create an empty Vec
res4: org.saddle.Vec[Double] = Empty Vec</pre>
</div>
<p>Sometimes random Vec instances are useful. There are a few ways to accomplish
this:</p>
<div class="code bash highlight-scala"><pre>scala&gt; vec.rand(1000)             // a thousand random doubles from -1.0 to 1.0 (excluding 0)
res16: org.saddle.Vec[Double] =
[1000 x 1]
-0.3647
-0.8776
-0.1852
 0.4713
 0.5310
 ...
-0.1232
-0.3302
 0.6612
 0.1838
-0.5100

scala&gt; vec.randp(1000)            // a thousand random positive doubles
res17: org.saddle.Vec[Double] =
[1000 x 1]
0.4377
0.2627
0.7381
0.5137
0.1575
 ...
0.6006
0.6870
0.9352
0.8327
0.9287

scala&gt; vec.randi(1000)            // a thousand random ints
res18: org.saddle.Vec[Int] =
[1000 x 1]
 1486232052
   79709566
 1053064649
  -33727419
 1788415839
 ...
 -690368198
-1546745697
 2110715984
 1291536312
 2041370436

scala&gt; vec.randpi(1000) % 10      // a thousand random positive ints, from 1 to 9
res19: org.saddle.Vec[Int] =
[1000 x 1]
7
7
2
7
3
 ...
1
7
2
6
4</pre>
</div>
<p>Let&#8217;s take a quick look at some operations you can do on Vec instances. All the
major arithmetic operations are supported.</p>
<div class="code bash highlight-scala"><pre>scala&gt; Vec(1,2,3) + Vec(4,5,6)
res0: org.saddle.Vec[Int] =
[3 x 1]
5
7
9

scala&gt; Vec(1,2,3) * Vec(4,5,6)
res1: org.saddle.Vec[Int] =
[3 x 1]
 4
10
18

scala&gt; Vec(1,2,3) dot Vec(4,5,6)
res2: Int = 32

scala&gt; Vec(1,2,3) outer Vec(4,5,6)
res3: org.saddle.Mat[Int] =
[3 x 3]
 4  5  6
 8 10 12
12 15 18

scala&gt; Vec(1,2,3) ** Vec(4,5,6)
res4: org.saddle.Vec[Int] =
[3 x 1]
  1
 32
729

scala&gt; Vec(1,2,3) &lt;&lt; 2
res5: org.saddle.Vec[Int] =
[3 x 1]
 4
 8
12

scala&gt; Vec(1,2,3) &amp; 0x1
res6: org.saddle.Vec[Int] =
[3 x 1]
1
0
1</pre>
</div>
<p>You can also slice out data from a Vec in various ways:</p>
<div class="code bash highlight-scala"><pre>scala&gt; val v = vec.rand(10)
v: org.saddle.Vec[Double] =
[10 x 1]
 0.2856
 0.0315
-0.1982
-0.0759
 0.8767
-0.9438
 0.9350
 0.4167
 0.6785
 0.2523

scala&gt; v.at(2)                // wrapped in Scalar, in case of NA
res0: org.saddle.scalar.Scalar[Double] = -0.19816001024987906

scala&gt; v.raw(2)               // raw access to primitive type
res1: Double = -0.19816001024987906

scala&gt; v(2,4,8)
res2: org.saddle.Vec[Double] =
[3 x 1]
-0.1982
 0.8767
 0.6785

scala&gt; v(2 -&gt; 4)
res3: org.saddle.Vec[Double] =
[3 x 1]
-0.1982
-0.0759
 0.8767

scala&gt; v(* -&gt; 3)
res4: org.saddle.Vec[Double] =
[4 x 1]
 0.2856
 0.0315
-0.1982
-0.0759

scala&gt; v( 8 -&gt; * )
res5: org.saddle.Vec[Double] =
[2 x 1]
0.6785
0.2523

scala&gt; v.slice(0,3)
res6: org.saddle.Vec[Double] =
[3 x 1]
 0.2856
 0.0315
-0.1982

scala&gt; v.slice(0,8,2)
res7: org.saddle.Vec[Double] =
[4 x 1]
 0.2856
-0.1982
 0.8767
 0.9350</pre>
</div>
<p>There are statistical functions available:</p>
<div class="code bash highlight-scala"><pre>scala&gt; val v = Vec(1,2,3)
v: org.saddle.Vec[Int] =
[3 x 1]
1
2
3

scala&gt; v.sum
res0: Int = 6

scala&gt; v.prod
res1: Int = 6

scala&gt; v.mean
res2: Double = 2.0

scala&gt; v.median
res3: Double = 2.0

scala&gt; v.max
res4: Option[Int] = Some(3)

scala&gt; v.stdev
res5: Double = 1.0

scala&gt; v.variance
res6: Double = 1.0

scala&gt; v.skew
res7: Double = 0.0

scala&gt; v.kurt
res8: Double = NaN

scala&gt; v.geomean
res9: Double = 1.8171205928321394</pre>
</div>
<p>As well as rolling statistical functions:</p>
<div class="code bash highlight-scala"><pre>scala&gt; val v = vec.rand(10)
v: org.saddle.Vec[Double] =
[10 x 1]
-0.9886
-0.2744
-0.9658
-0.6449
-0.6503
 0.9905
 0.7850
-0.2355
-0.1104
 0.9301

scala&gt; v.rollingSum(5)            // window size = 5
res0: org.saddle.Vec[Double] =
[6 x 1]
-3.5240
-2.2592
-0.5084
-0.0990
 0.4410
 0.3806

scala&gt; v.rollingMean(5)
res1: org.saddle.Vec[Double] =
[6 x 1]
-0.7048
-0.4518
-0.1017
-0.0198
 0.0882
 0.0761

scala&gt; v.rollingMedian(5)
res2: org.saddle.Vec[Double] =
[6 x 1]
-0.6503
-0.6449
-0.6449
-0.2355
-0.1104
 0.7850</pre>
</div>
<p>In fact, you can do any calculation you&#8217;d like over the rolling window:</p>
<div class="code bash highlight-scala"><pre>scala&gt; v.rolling(5, _.stdev)      // window size = 5, take stdev of vector input
res0: org.saddle.Vec[Double] =
[6 x 1]
0.5456
0.3810
0.3685
0.2678
0.6302
0.4969</pre>
</div>
<p>Let&#8217;s take a quick look at some more advanced functionality:</p>
<div class="code bash highlight-scala"><pre>scala&gt; val v = vec.rand(10)
v: org.saddle.Vec[Double] =
[10 x 1]
-0.0137
 0.8427
-0.0089
 0.2083
 0.9968
-0.3560
-0.5520
-0.2475
-0.5036
-0.3474

scala&gt; v filter(_ &gt; 0.5)
res0: org.saddle.Vec[Double] =
[2 x 1]
0.8427
0.9968

scala&gt; v where v &gt; 0.5
res1: org.saddle.Vec[Double] =
[2 x 1]
0.8427
0.9968

scala&gt; v.take(v.find(_ &gt; 0.5))
res2: org.saddle.Vec[Double] =
[2 x 1]
0.8427
0.9968

scala&gt; v.filterFoldLeft(_ &gt; 0.5)(0d) { case (acc, d) =&gt; acc + d }
res3: Double = 1.8394622034464525

scala&gt; v shift 1
res4: org.saddle.Vec[Double] =
[10 x 1]
     NA
-0.0137
 0.8427
-0.0089
 0.2083
 0.9968
-0.3560
-0.5520
-0.2475
-0.5036</pre>
</div>
<p>Try out the following:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="mi">0</span><span class="n">d</span><span class="o">)</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">acc</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">d</span> <span class="o">}</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span> <span class="n">without</span> <span class="n">v</span><span class="o">.</span><span class="n">find</span><span class="o">(</span><span class="k">_</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span> <span class="n">findOne</span><span class="o">(</span><span class="k">_</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">head</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">tail</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">(</span><span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">).</span><span class="n">mask</span><span class="o">(</span><span class="nc">Vec</span><span class="o">(</span><span class="kc">true</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">))</span>
</pre></div>
</div>
<p>Note that NA (missing values) are handled within calculations by being ignored:</p>
<div class="code bash highlight-scala"><pre>scala&gt; val v = Vec(1, na.to[Int], 2)
v: org.saddle.Vec[Int] =
[3 x 1]
 1
NA
 2

scala&gt; v sum
res0: Int = 3

scala&gt; v median
res1: Double = 1.5

scala&gt; v prod
res2: Int = 2

scala&gt; v dropNA
res3: org.saddle.Vec[Int] =
[2 x 1]
1
2

scala&gt; v.at(1)                    // boxed to prevent shooting yourself in foot
res4: org.saddle.scalar.Scalar[Int] = NA

scala&gt; v.raw(1)                   // be careful!
res5: Int = -2147483648

scala&gt; v.fillNA(_ =&gt; 5)           // ignore argument, which is index of NA
res6: org.saddle.Vec[Int] =
[3 x 1]
1
5
2</pre>
</div>
<p>Scalar[T] may implicitly convert to Option[T], so you may do everything you
expect to do with an Option, such as map or flatmap over it.</p>
<p>Finally, if you need to treat a Vec as a sequence, you may convert it to one
explicitly by calling Vec.toSeq. Also, to access (a copy of) Vec as an array,
you may call Vec.contents.</p>
</div>
<div class="section" id="series">
<h2>Series<a class="headerlink" href="#series" title="Permalink to this headline">¶</a></h2>
<p>A Series combines a Vec with an Index that provides a key-value mapping. Let&#8217;s
take a look at some things you can do.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebarwrapper">
      <div class="sphinxsidebar">
  <div class="logo">
    <a href="index.html">
      <img class="logo" src="_static/logo.png" width=200 alt="Logo"/>
    </a>
  </div>
  <ul>
<li><a class="reference internal" href="#">Quick Start Guide</a><ul>
<li><a class="reference internal" href="#vec">Vec</a></li>
<li><a class="reference internal" href="#series">Series</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Welcome to Saddle Docs</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="guide.html"
                        title="next chapter">User Guide</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
        &copy; Copyright 2013, The Saddle Development Team.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>